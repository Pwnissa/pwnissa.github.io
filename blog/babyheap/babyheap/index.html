<!DOCTYPE html><html lang="it" data-astro-cid-4dqtj3le> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="manifest" href="/site.webmanifest"><meta name="generator" content="Astro v5.17.2"><meta name="description" content="Articolo di ub1k @ Pwnissa"><title>Babyheap: JustCTF - Chapter 1</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><style>.footer[data-astro-cid-sz7xmlte]{background:var(--bg-secondary);padding:60px 0 20px;border-top:1px solid var(--card-border);margin-top:0}.footer-content[data-astro-cid-sz7xmlte]{max-width:1200px;margin:0 auto;padding:0 20px;text-align:center}.footer[data-astro-cid-sz7xmlte] h2[data-astro-cid-sz7xmlte]{font-size:2rem;margin-bottom:30px;color:var(--accent-gold)}.contact-info[data-astro-cid-sz7xmlte]{display:flex;flex-direction:column;gap:15px;font-size:1.1rem}.contact-info[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{color:var(--accent-teal);text-decoration:none;transition:color .3s ease}.contact-info[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:var(--accent-gold)}.made-by[data-astro-cid-sz7xmlte]{margin-top:15px;font-size:.75rem;color:#fff;text-align:center}.made-by[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]{color:#fff;text-decoration:none;transition:color .3s ease}.made-by[data-astro-cid-sz7xmlte] a[data-astro-cid-sz7xmlte]:hover{color:var(--accent-gold)}
</style>
<link rel="stylesheet" href="/_astro/babyheap.DdGESeJp.css"></head> <body data-astro-cid-4dqtj3le> <nav id="fixedNavbar" class="fixed-navbar" data-astro-cid-uvvofgxd> <div class="navbar-container" data-astro-cid-uvvofgxd> <div class="navbar-brand" data-astro-cid-uvvofgxd> <a href="/" data-astro-cid-uvvofgxd>Pwnissa</a> </div> <div class="navbar-menu" data-astro-cid-uvvofgxd> <a href="/blog" class="navbar-link" data-astro-cid-uvvofgxd>Blog</a><a href="/members" class="navbar-link" data-astro-cid-uvvofgxd>Members</a> </div> </div> </nav> <script type="module">let e=window.scrollY;const l=document.getElementById("fixedNavbar"),o=()=>{window.scrollY>e+5&&window.scrollY>l.offsetHeight?l.classList.add("hidden"):window.scrollY<e-5&&l.classList.remove("hidden"),e=window.scrollY};window.addEventListener("scroll",o);document.addEventListener("DOMContentLoaded",()=>{l.classList.remove("hidden")});</script>  <main class="blog-container" data-astro-cid-4dqtj3le> <div class="blog-header" data-astro-cid-4dqtj3le> <a href="/" class="back-link" data-astro-cid-4dqtj3le>‚Üê Torna alla home</a> <div class="article-meta" data-astro-cid-4dqtj3le> <h1 data-astro-cid-4dqtj3le>Babyheap: JustCTF - Chapter 1</h1> <div class="meta-info" data-astro-cid-4dqtj3le> <span class="author" data-astro-cid-4dqtj3le>di ub1k</span> <span class="date" data-astro-cid-4dqtj3le>20/10/2025</span> <div class="tags" data-astro-cid-4dqtj3le> <span class="tag pwn" data-astro-cid-4dqtj3le>pwn</span><span class="tag heap" data-astro-cid-4dqtj3le>heap</span><span class="tag environ" data-astro-cid-4dqtj3le>environ</span><span class="tag rop" data-astro-cid-4dqtj3le>rop</span> </div> </div> </div> </div> <article class="article-content" data-astro-cid-4dqtj3le> <p>Normally, especially for beginners, seeing a baby challenge is always a very refreshing alternative to the high level tasks made to challenge also the best of players.</p>
<p>You solve a very simple challenge and have the possibility to encounter a new technique in a simple and protected setting. Baby heap breaks one of these assumptions, to be fair, it was never written which type of <em>baby</em> is intended in the title, a newborn beluga whale for example can weight even <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">100</span></span></span></span>kg, enough to crush my sanity.</p>
<p>By the end of this write-up, I hope you‚Äôll understand both my frustration and my realization: maybe my assumptions about baby challenges were wrong from the start. In fact, I learned more about <code>libc</code> internals and exploitation techniques in this single challenge than in all the other ‚Äúbaby‚Äù ones combined.</p>
<p>This is a two-part journey: from simple heap exploitation to advanced techniques, and finally, as dessert, an <code>exit_function</code> overwrite and <code>environ</code> leak.</p>
<h1 id="the-disassembly">The disassembly</h1>
<p>As usual, we are not going to look at the entire binary, but instead focusing on the relevant parts. For context, the program is straightforward:</p>
<ul>
<li><code>create_chunk()</code> Allocates a buffer of size <code>0x30</code>.</li>
<li><code>modify_chunk()</code> Allows you to overwrite the contents of an existing chunk.</li>
<li><code>read_chunk()</code> Reads the full <code>0x30</code> bytes from a chunk.</li>
<li><code>delete_chunk()</code> Frees the chunk.</li>
</ul>
<p>We are gonna concentrate on two of these functions:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//babyheap</span></span>
<span class="line"><span style="color:#FF79C6">int</span><span style="color:#50FA7B"> create_chunk</span><span style="color:#F8F8F2">()</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">  int</span><span style="color:#F8F8F2"> index;</span><span style="color:#6272A4"> // [rsp+Ch] [rbp-4h]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">  index </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> get_index</span><span style="color:#F8F8F2">();</span></span>
<span class="line"><span style="color:#FF79C6">  if</span><span style="color:#F8F8F2"> ( </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">((_QWORD </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">chunks </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> index) )</span></span>
<span class="line"><span style="color:#FF79C6">	return</span><span style="color:#50FA7B"> puts</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">This index is already in use</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#FF79C6">  *</span><span style="color:#F8F8F2">((_QWORD </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">chunks </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> index) </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> malloc</span><span style="color:#F8F8F2">(</span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">30</span><span style="color:#FF79C6">uLL</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#50FA7B">  printf</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">Content? </span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#50FA7B">  printf</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">Content? </span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span><span style="color:#6272A4"> //wtf why?</span></span>
<span class="line"><span style="color:#FF79C6">  return</span><span style="color:#50FA7B"> read</span><span style="color:#F8F8F2">(</span><span style="color:#BD93F9">0</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">((</span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> **</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">chunks </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> index), </span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">30</span><span style="color:#FF79C6">uLL</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>As described above, this function creates a chunk and saves the address to an array of max <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>20</mn></mrow><annotation encoding="application/x-tex">20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">20</span></span></span></span> entries, if the entry is occupied it returns without allocating and gives an error message.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//babyheap</span></span>
<span class="line"><span style="color:#FF79C6">void</span><span style="color:#50FA7B"> delete_chunk</span><span style="color:#F8F8F2">()</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">  int</span><span style="color:#F8F8F2"> index;</span><span style="color:#6272A4"> // [rsp+Ch] [rbp-4h]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">  index </span><span style="color:#FF79C6">=</span><span style="color:#50FA7B"> get_index</span><span style="color:#F8F8F2">();</span></span>
<span class="line"><span style="color:#FF79C6">  if</span><span style="color:#F8F8F2"> ( </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">((_QWORD </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">chunks </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> index) )</span></span>
<span class="line"><span style="color:#50FA7B">    free</span><span style="color:#F8F8F2">(</span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">((</span><span style="color:#FF79C6">void</span><span style="color:#FF79C6"> **</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">chunks </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> index));</span></span>
<span class="line"><span style="color:#FF79C6">  else</span></span>
<span class="line"><span style="color:#50FA7B">    puts</span><span style="color:#F8F8F2">(</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">This chunk is empty</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">);</span></span>
<span class="line"><span style="color:#F8F8F2">}</span></span></code></pre>
<p>Looking at the <code>delete_chunk()</code>function we notice that it doesn‚Äôt remove the address from the array once deleted. This has a few implications, <em>first</em> it is possible to read and write to a freed chunk, and <em>second</em>, once created a chunk you cannot call a second time <code>create_chunk()</code> on the same index, this limits our <code>create_chunk()</code> calls to maximum 20.</p>
<h1 id="heap-exploitation">Heap Exploitation</h1>
<div class="callout" data-type="warning" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);">‚ö†Ô∏è</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);">Warning</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <p><strong>Heap exploitation</strong> is a complex topic, so I won‚Äôt go too deep here. If you are interested here is a link to some <a href="https://5o1z.github.io/blog/heapexploitation/getting_started/">material</a>.</p> </div> </div> 
<p>When <code>malloc()</code> is called, generally, a memory address to the heap is returned, this address points to the user data of a struct, the sections above contain important metadata. We like to call this memory areas chunks.</p>
<p><img src="/_astro/writeup-002.BI4_968T_2bO952.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1016" height="158"></p>
<p><strong>From now one we will consider the header part of the chunk, so it‚Äôs size becomes 0x40 instead of 0x30.</strong>
Looking at the chunks header, we notice a few significant fields: The size field stores the amount of bytes that divide this chunk from the next one, yet nothing stops us from writing more bytes than the amount specified in the size field.
Another interesting part is the P flag, if <code>prev_used</code> is set, free() knows that the previous chunk is currently allocated, if the flag isn‚Äôt set, the allocator could try to fuse together the two chunks to create a bigger one.</p>
<h2 id="the-bins">The bins</h2>
<p>When a chunk is freed, from <code>LIBC-2.26</code> onwards the deallocator first tries to place an address pointing to the user data as the first element of a per-size-class singly linked list called the <strong>tcache</strong>, which can hold up to 7 elements in every class of max 0x410 bytes of size.</p>
<p>In the free operation, the first 0x10 bytes of the user data are overwritten with a pointer to the next chunk in the list (fd) and a random value called tcache key used to prevent double frees (not to be confused with the tcache <strong>mangling</strong> key explained later in this chapter). This means that when a freed chunk is read, you won‚Äôt read the content it stored before but a pointer to a previously freed chunk or, if this is the first freed chunk, a null pointer.</p>
<p><img src="/_astro/writeup-003.0Jh8B3na_ZU4I36.webp" alt="|470x182" loading="lazy" decoding="async" fetchpriority="auto" width="618" height="240"></p>
<p>If more than 7 chunks of the same size are freed, and the chunk is between <code>0x20</code> and <code>0x80</code> bytes long, the allocator adds them into the <strong>fastbin</strong>. Fastbins have no limit on the number of chunks they can store, but are limited by the before mentioned size classes, also the fd pointer doesn‚Äôt point to the next fd pointer but to the prev_size field.</p>
<p>If the tcache is full and the elements are not compatible with the fastbin size-classes, or in very specific cases when mechanisms trigger <em>fastbin consolidation</em> (foreshadowing), chunks are placed into the <strong>unsortedbin</strong>. From there they can get sorted into <strong>largebins</strong> or <strong>smallbins</strong>.</p>
<p>This last three bins are implemented as doubly-linked circular lists. These have their head stored in the <strong>libc address space</strong>, to be more precise, in the <code>main_arena</code>, and because of the circular nature of these lists, the <strong>last</strong> element has a forward (fd) pointer to the head of the list stored in the arena, also because of the double-link, the <strong>first</strong> element has a backwards pointer (bk) to it too. So by reading a freed chunk in these bins you can receive a libc leak.</p>
<h2 id="tcache-poisoning">tcache poisoning</h2>
<p>If this binary had <strong>Partial RELRO</strong> and was <strong>non-PIE</strong>, we could have allocated two chunks and then freed them.<br/>
Once freed, both chunks would be placed into the <code>tcache</code> linked list, and where their data once resides, pointers to the next chunk in the linked list would now be written. By modifying the last freed chunk‚Äôs forward pointer (first element in the tcache list) to point to something like the GOT, the allocator would think that the first deallocated chunk (second element in the tcache) is stored in the GOT table.</p>
<div class="callout" data-type="warning" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);">‚ö†Ô∏è</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);">Warning</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(242, 138, 46, 0.05);--borderColor: var(--accent-orange);--iconColor: var(--accent-orange);"> <p>From <code>LIBC-2.32</code> The forward pointer (<code>fd</code>) addresses saved in the freed tcache entries are <strong>encoded</strong> (mangled).</p><pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//libc internals</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> PROTECT_PTR</span><span style="color:#F8F8F2">(</span><span style="color:#FFB86C;font-style:italic">pos</span><span style="color:#F8F8F2">, </span><span style="color:#FFB86C;font-style:italic">ptr</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">\</span></span>
<span class="line"><span style="color:#F8F8F2">  ((</span><span style="color:#50FA7B">__typeof</span><span style="color:#F8F8F2"> (ptr)) ((((</span><span style="color:#FF79C6">size_t</span><span style="color:#F8F8F2">) pos) </span><span style="color:#FF79C6">&gt;&gt;</span><span style="color:#BD93F9"> 12</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">^</span><span style="color:#F8F8F2"> ((</span><span style="color:#FF79C6">size_t</span><span style="color:#F8F8F2">) ptr)))</span></span>
<span class="line"><span style="color:#FF79C6">#define</span><span style="color:#50FA7B"> REVEAL_PTR</span><span style="color:#F8F8F2">(</span><span style="color:#FFB86C;font-style:italic">ptr</span><span style="color:#F8F8F2">)  </span><span style="color:#50FA7B">PROTECT_PTR</span><span style="color:#F8F8F2"> (</span><span style="color:#FF79C6">&amp;</span><span style="color:#F8F8F2">ptr, ptr)</span></span></code></pre><p>The macro takes as input the position where the pointer is saved and the location where the pointer is pointing too.</p><p>It then shifts away the 12 least significant bits of the position value, a memory page is generaly 0x1000 (16 bits) long, so we are removing the information about page internal positioning, leaving only the <strong>page address</strong>. In other words two chunks in the same page will have the same <code>((size_t) pos) &gt;&gt; 12)</code> value.
It then xores this value with the pointer to mangle it.</p><p>This ensures that the <em>encoded value depends both on the pointer and on the page where it is stored</em>. Pointers stored in different pages will be mangled differently, even if they point to the same target.</p><p>By doing the same operatin again we can reveal the pointer.</p><p>But this encoding is easily reversed, the page address used for mangling is part of the address itself, so this algorithm could be defined as a deterministic scramble. Xoring the mangled pointer with shifted parts of itself completly decodes the pointer.</p><pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#FF79C6">def</span><span style="color:#50FA7B"> demangle_alone</span><span style="color:#F8F8F2">(</span><span style="color:#FFB86C;font-style:italic">ptr</span><span style="color:#F8F8F2">,</span><span style="color:#FFB86C;font-style:italic">page_offset</span><span style="color:#FF79C6">=</span><span style="color:#BD93F9">0</span><span style="color:#F8F8F2">):</span></span>
<span class="line"><span style="color:#F8F8F2">	mid </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> ptr </span><span style="color:#FF79C6">^</span><span style="color:#F8F8F2"> ((ptr</span><span style="color:#FF79C6">&gt;&gt;</span><span style="color:#BD93F9">12</span><span style="color:#F8F8F2">)</span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2">page_offset)</span></span>
<span class="line"><span style="color:#FF79C6">  	return</span><span style="color:#F8F8F2"> mid </span><span style="color:#FF79C6">^</span><span style="color:#F8F8F2"> (mid</span><span style="color:#FF79C6">&gt;&gt;</span><span style="color:#BD93F9">24</span><span style="color:#F8F8F2">)</span></span></code></pre> </div> </div> 
<p>Then, by reallocating the two chunks, the allocator would return the address of the GOT as the second allocation (the first 16 bytes get zeroed out, look at the note below), we could then:</p>
<ol>
<li><strong>Read</strong> from the GOT by reading from the second chunk to leak a libc address, but this only works with ‚Äòfwrite()‚Äô or similar because the first 0x10 bytes are null pointers terminating ‚Äòprintf‚Äô or ‚Äòputs‚Äô instantly.</li>
<li><strong>Overwrite</strong> a GOT entry (<code>free</code>) with the address of <code>system()</code>, giving us a shell the next time that function is called.</li>
</ol>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p>From <code>LIBC-2.29</code> after the 8 byte fd pointer saved in the chunk, another 8 bytes get used to store the <strong>tcache key</strong>, these <strong>16 bytes get zeroed out</strong> when a chunk gets allocated. If this tcache key is present when a free operation is done, that tcache bin gets checked for a double free, else no check is done.</p> </div> </div> 
<p>But that‚Äôs not the case here‚Ä¶ behold:</p>
<p><img src="/_astro/writeup-006.CtsKCqo9_Z1dy5Nj.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="483" height="175"></p>
<p>Still, this very simple technique called <strong>tcache poisoning</strong> will prove useful several times throughout this writeup.</p>
<p>But let‚Äôs exit this hypothetical scenario and focus on the real limitations we face: the binary has <strong>no apparent address leak</strong> and <strong>no buffer overflow</strong>, we need to take control in some other way.</p>
<h1 id="the-plan">The Plan</h1>
<p>Our actual goal is to gain <strong>arbitrary read and write primitives within libc</strong>. With these, we can leak crucial pointers like <code>__envrion</code>, <code>__exit_functions</code> or other stuff, and eventually get to a shell.
At this point, it‚Äôs worth clarifying that I didn‚Äôt solve this challenge during the competition itself. Instead, I studied various writeups to deeply understand the possible solutions and their underlying mechanics.</p>
<p>I‚Äôll present <strong>two</strong> methods to leak a libc pointer, followed by <strong>two</strong> techniques to leverage that leak to achieve a shell. The first leak and exploit can be found in this part, the second part includes a more exotic variant.</p>
<h1 id="house-of-something">House of something</h1>
<p>As explained in the heap primer, the heads of the linked lists for <code>smallbin</code>, <code>largebin</code>, and <code>unsortedbin</code> live in <code>main_arena</code> inside libc. Those lists are doubly linked and circular. If we can move a chunk into one of those bins we can read the <code>fd</code> pointer that points back into libc and obtain a libc leak usable later.</p>
<p>Sending a chunk into those bins requires freeing a large enough chunk. The tcache holds chunks up to size <code>0x410</code> (inclusive), so we must either create a single chunk larger than <code>0x410</code> or free more than seven smaller chunks while avoiding the fastbin path (above 0x80 bytes), we will try to deallocate a 0x410 or greater size chunk.</p>
<h2 id="reasoning-about-chunks">Reasoning about chunks</h2>
<p><strong>Question</strong>: By manipulating a chunk‚Äôs fd pointer (tcache poisoning) to position the next chunk in the tcache list just above a previously allocated third chunk, is it possible to use the first chunk to alter the size metadata of the second chunk, so that when the third chunk is freed, the allocator interprets its size as 0x420 bytes and moves the chunk into unsortedbin?</p>
<p>In theory, <strong>yes</strong>, but with important caveats. We must have a second chunk immediately after our forged chunk (including it‚Äôs modified size), in this way when we free the giant chunk it doesn‚Äôt get trimmed away.<br/>
Targeting a 0x420 size will cross past the current top chunk, so we need to allocate enough intermediate chunks until our <em>guard chunk</em> (the second chunk mentioned before) sits directly after our forged chunk. Only then can freeing the forged chunk make the allocator interpret a 0x420 size and move the chunk to unsortedbin instead of trimming it away, producing the desired libc leak.</p>
<p>To guarantee that an extra chunk is placed immediately behind our forged <code>0x420</code> chunk we expand the forged size slightly to <code>0x440</code>. Because small chunks are <code>0x40</code> bytes, the <code>0x440</code> size ensures the forged chunk completely overlaps the final small chunk in that region.</p>
<p><img src="/_astro/writeup-001-3.BLTJGVY8_oSLqi.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1472" height="402"></p>
<p>But it‚Äôs not so simple, with 19 allocations we don‚Äôt have enough chunks to push the top chunk behind our forged one and also have enough allocations to do some tcache poisoning for our final exploitation. We need another strategy.</p>
<h2 id="tcache_perthread_struct">tcache_perthread_struct</h2>
<p>The Tcache has a significant property that the other bins don‚Äôt have, it is local to a specific thread, if more threads are present in the process, more tcaches are created. To make this work, for every thread a tcache struct called <code>tcache_perthread_struct</code> is allocated that contains the heads of the linked lists and the number of freed chunks. For our primary thread the 0x290 bytes long perthread_struct is allocated at the top.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6272A4">//glibc internals https://elixir.bootlin.com/glibc/glibc-2.42/source/malloc/malloc.c#L3127</span></span>
<span class="line"><span style="color:#FF79C6">typedef</span><span style="color:#FF79C6"> struct</span><span style="color:#F8F8F2"> tcache_perthread_struct</span></span>
<span class="line"><span style="color:#F8F8F2">{</span></span>
<span class="line"><span style="color:#FF79C6">  uint16_t</span><span style="color:#F8F8F2"> num_slots[TCACHE_MAX_BINS];</span></span>
<span class="line"><span style="color:#F8F8F2">  tcache_entry </span><span style="color:#FF79C6">*</span><span style="color:#F8F8F2">entries[TCACHE_MAX_BINS];</span></span>
<span class="line"><span style="color:#F8F8F2">} tcache_perthread_struct;</span></span></code></pre>
<p>By using the <code>heap</code> command in pwndbg we can spot the perthread chunk (first one), the second one is a 0x40 chunk created through the menu of the program and the last on is the topchunk:</p>
<p><img src="/_astro/writeup-001-4.6pFoylWD_1EocQQ.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="932" height="274"></p>
<p><strong>So, could we use this chunk as our forged chunk?</strong><br/>
Yes. Even though we never directly allocated this chunk and thus did not receive its pointer, we can still allocate a new chunk that completely overlaps the first 0x40 bytes of the <code>perthread_struct</code>. From there, we can modify its size field using a slightly overlapping chunk, just like the technique described earlier. By adding new chunks the allocator will place them after the 0x290 perthread_chunk like in the image above.</p>
<p>This approach significantly reduces the number of required allocations to correctly position the guard chunk, from 16 allocations (excluding the guard and the two overlapping chunks) down to just 6.</p>
<p>The main drawback is that the <code>perthread_struct</code> becomes corrupted, breaking the tcache metadata, in particular the amount of stored chunks saved at the beginning of the struct get zeroed out by the allocation and filed with values at the deallocation. Nevertheless, this appears to be our only viable option for obtaining a chunk large enough for the intended purpose.</p>
<h2 id="you-are-0x440-bytes-big-trust-me">You are 0x440 bytes big, trust me</h2>
<p>Talk is cheap, so let‚Äôs move to the practical part.<br/>
We‚Äôll use <strong>tcache poisoning</strong> to place a chunk precisely at the location of the <code>perthread_chunk</code> the deallocator will mistake the perthread_chunks size as the one of our own chunks. Then, we allocate a second chunk and poison the tcache again so that it partially overlaps the <code>perthread</code>/fake-chunk metadata. This overlapping chunk gives us write access to the <code>perthread</code> metadata, allowing us to modify its size field from <code>0x290</code> to <code>0x440</code>.</p>
<p>Next, we allocate enough chunks to push the <code>top</code> chunk downward, six allocations plus the guard chunk.<br/>
By looking at the addresses of the chunks in the image below we can notice the modified <code>perthread</code> chunk with the guard chunk right beneath it.</p>
<p><img src="/_astro/writeup-002-1.BWUXQeVR_ZgNXAY.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="932" height="275"></p>
<p>Finally, we free the chunk placed over the <code>perthread</code> structure, the deallocator will check the size and moves the pointer to the <strong>unsorted bin</strong>. During this process, the unsorted bin writes <code>fd</code> (forward) and <code>bk</code> (backward) pointers into the freed chunk; these pointers reference <code>main_arena</code>. Reading from the freed chunk‚Äôs user area thus reveals a <strong>libc pointer leak</strong>!.</p>
<p><img src="/_astro/writeup-003-1.016LsJCW_Z1L4iSr.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1163" height="377"></p>
<h1 id="rop-exploit-using-__environ">ROP exploit using <code>__environ</code></h1>
<p>Once we have arbitrary read and write into the libc getting a leak to the stack is very simple, enter <code>__environ</code>.</p>
<h3 id="the-__environ-variable">The __environ variable</h3>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p>Yes, here‚Äôs a joke about <code>__environ</code>:
<code>__environ</code> goes to therapy. Talks nonstop for hours.
Then it asks, ‚ÄúWhy always me?‚Äù<br/>
Therapist responds, ‚ÄúIt all comes from your environment.‚Äù</p> </div> </div> 
<p><code>__environ</code> is a global variable pointing to the environment variables saved on the stack:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F8F8F2">environ </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> libc_base </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> libc.symbols.__environ</span></span></code></pre>
<h3 id="the-rop-chain">The ROP chain</h3>
<p>We can use <strong>tcache poisoning</strong> to overwrite the <code>fd</code> pointer of the first freed chunk with the address of <code>__environ</code>. After allocating twice, the second allocation will return a chunk overlapping the <code>__environ</code> pointer.</p>
<p>Keep in mind: <code>malloc()</code> zeroes out the first <code>0x10</code> bytes, so we must allocate at an <strong>offset</strong>. In this case, we offset by <code>0x18</code> because chunks must also be aligned to <code>0x10</code>:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F8F8F2">environ_leak </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> u64(read(r, </span><span style="color:#BD93F9">10</span><span style="color:#F8F8F2">)[</span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">18</span><span style="color:#F8F8F2">:</span><span style="color:#FF79C6">0x</span><span style="color:#BD93F9">20</span><span style="color:#F8F8F2">])</span></span></code></pre>
<p>From here we get the environment stack variables and subtract the <code>main</code> return address from it, we get a permanent offset that when added on our environ leak will yield us the main address.</p>
<p>Using our <strong>tcache poisoning technique</strong> again, we can modify the return address and set a ROP gadget chain, I opted for:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F8F8F2">pop_rdi </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> libc_base </span><span style="color:#FF79C6">+</span><span style="color:#FF79C6"> 0x</span><span style="color:#BD93F9">000000000010f75b</span></span>
<span class="line"><span style="color:#F8F8F2">binsh </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> libc.binsh() </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> libc_base</span></span>
<span class="line"><span style="color:#F8F8F2">ret </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> pop_rdi </span><span style="color:#FF79C6">+</span><span style="color:#BD93F9"> 1</span></span>
<span class="line"><span style="color:#F8F8F2">system </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> libc_base </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> libc.symbols.system</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F8F8F2">return_pointer </span><span style="color:#FF79C6">=</span><span style="color:#F8F8F2"> environ_leak </span><span style="color:#FF79C6">-</span><span style="color:#FF79C6"> 0x</span><span style="color:#BD93F9">130</span><span style="color:#6272A4"> # 0x130 is the offset from environ to main return</span></span>
<span class="line"><span style="color:#F8F8F2">update(r, </span><span style="color:#BD93F9">9</span><span style="color:#F8F8F2">, p64((return_pointer</span><span style="color:#FF79C6">-0x</span><span style="color:#BD93F9">08</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">^</span><span style="color:#F8F8F2"> mask)) </span><span style="color:#6272A4"># 0x08 for heap alignment</span></span>
<span class="line"><span style="color:#F8F8F2">create(r, </span><span style="color:#BD93F9">11</span><span style="color:#F8F8F2">, </span><span style="color:#FF79C6">b</span><span style="color:#E9F284">&quot;</span><span style="color:#F1FA8C">dummy</span><span style="color:#E9F284">&quot;</span><span style="color:#F8F8F2">)</span></span>
<span class="line"><span style="color:#F8F8F2">create(r, </span><span style="color:#BD93F9">12</span><span style="color:#F8F8F2">, p64(</span><span style="color:#BD93F9">0</span><span style="color:#F8F8F2">) </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> p64(pop_rdi) </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> p64(binsh) </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> p64(ret) </span><span style="color:#FF79C6">+</span><span style="color:#F8F8F2"> p64(system))</span></span>
<span class="line"></span></code></pre>
<p>We need to add a single ret instruction because the stack is not aligned to a multiple of <code>0x10</code>. Using the <code>pop rdi</code> instruction and summing <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em"></span><span class="mord">1</span></span></span></span> gives us a single <code>ret</code> instruction because <code>pop rdi</code> is a single byte.</p>
<div class="callout" data-type="info" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <div class="callout-header" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <span class="callout-icon" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">üìã</span> <span class="callout-title" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);">Info</span> </div> <div class="callout-content" data-astro-cid-mrmim4ef style="--bgColor: rgba(204, 204, 204, 0.05);--borderColor: var(--text-secondary);--iconColor: var(--text-secondary);"> <p>Sometimes a perfect ROP chain still crashes the target. One common cause is stack misalignment. Many <code>libc</code> functions require the stack to be <code>0x10</code> aligned to accommodate <a href="https://stackoverflow.com/questions/1422149/what-is-vectorization#1422181">SIMD instructions</a> . Adding a single <code>ret</code> gadget before your chain moves the stack by <code>0x08</code>, fixing the alignment.</p> </div> </div> 
<p>Now when returning <code>system(/bin/sh)</code> will be executed giving us a <strong>shell</strong>.</p> </article> </main> <footer class="footer" data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <h2 data-astro-cid-sz7xmlte>Contacts</h2> <div class="contact-info" data-astro-cid-sz7xmlte> <p data-astro-cid-sz7xmlte>üìß Email: <a href="mailto:info@pwnissa.it" data-astro-cid-sz7xmlte>info@pwnissa.it</a></p> <p data-astro-cid-sz7xmlte>üêô GitHub: <a href="https://github.com/pwnissa" target="_blank" data-astro-cid-sz7xmlte>https://github.com/pwnissa</a></p> <p data-astro-cid-sz7xmlte>üìç Universit√† degli Studi di Genova, DIBRIS</p> </div> <p class="made-by" data-astro-cid-sz7xmlte>Made with ‚ô• by <a href="https://stealthguy.net" target="_blank" rel="noopener noreferrer" data-astro-cid-sz7xmlte>stealthguy</a></p> </div> </footer>  </body></html>